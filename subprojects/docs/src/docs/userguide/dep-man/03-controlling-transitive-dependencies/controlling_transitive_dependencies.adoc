[[controlling-transitive-dependencies]]
= Controlling transitive dependencies

[[sec:direct-vs-transitive-deps]]
== Direct dependencies vs dependency constraints

A component may have two different kinds of dependencies:

- direct dependencies are _directly required by the component_.
A direct dependency is also referred to as a _first level dependency_.
For example, if your project source code requires Guava, Guava should be declared as _direct dependency_.
- transitive dependencies are dependencies that your component needs, but only because another dependency needs them.

It's quite common that issues with dependency management are about _transitive dependencies_.
Often developers incorrectly fix transitive dependency issues by adding _direct dependencies_.
To avoid this, Gradle provides the concept of _dependency constraints_.

[[sec:adding-constraints-transitive-deps]]
== Adding constraints on transitive dependencies

Dependency constraints allow you to define the version or the version range of both dependencies declared in the build script and transitive dependencies.
It is the preferred method to express constraints that should be applied to all dependencies of a configuration.
When Gradle attempts to resolve a dependency to a module version, all <<rich_versions.adoc#,dependency declarations with version>>, all transitive dependencies and all dependency constraints for that module are taken into consideration.
The highest version that matches all conditions is selected.
If no such version is found, Gradle fails with an error showing the conflicting declarations.
If this happens you can adjust your dependencies or dependency constraints declarations, or make other adjustments to the transitive dependencies if needed.
Similar to dependency declarations, dependency constraint declarations are <<declaring_dependencies.adoc#sec:what-are-dependency-configurations,scoped by configurations>> and can therefore be selectively defined for parts of a build.
If a dependency constraint influenced the resolution result, any type of <<#sec:dependency_resolve_rules,dependency resolve rules>> may still be applied afterwards.

.Define dependency constraints
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/versionsWithConstraints/groovy",files="build.gradle[tags=dependency-constraints]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/versionsWithConstraints/kotlin",files="build.gradle.kts[tags=dependency-constraints]"]
====

In the example, all versions are omitted from the dependency declaration.
Instead, the versions are defined in the constraints block.
The version definition for `commons-codec:1.11` is only taken into account if `commons-codec` is brought in as transitive dependency, since `commons-codec` is not defined as dependency in the project.
Otherwise, the constraint has no effect.
Dependency constraints can also define a <<rich_versions.adoc#,rich version constraint>> and support <<declaring_dependency_versions.adoc#sec:declaring_for_subgraph,subgraph version constraints>> to enforce a version even if it contradicts with the version defined by a transitive dependency (e.g. if the version needs to be downgraded).

[NOTE]
====
Dependency constraints are only published when using <<publishing.adoc#understanding-gradle-module-md,Gradle Module Metadata>>.
This means that currently they are only fully supported if Gradle is used for publishing and consuming (i.e. they are 'lost' when consuming modules with Maven or Ivy).
====

Dependency constraints themselves can also be added transitively.

[[sec:using-platform-to-control-transitive-deps]]
== Using a platform to control transitive versions

[[sub:sharing-dep-versions-between-projects]]
=== Sharing dependency versions between projects

// A dependency to a platform inherits all subgraph constraints of the platform (can be turned off by 'notInheritConstraints()')

[[sub:enforced-platforms]]
=== Enforced platforms

[[sub:bom_import]]
=== Importing Maven BOMs

Gradle provides support for importing https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Importing_Dependencies[bill of materials (BOM) files], which are effectively `.pom` files that use `<dependencyManagement>` to control the dependency versions of direct and transitive dependencies.
The BOM support in Gradle works similar to using `<scope>import</scope>` when depending on a BOM in Maven.
In Gradle however, it is done via a regular dependency declaration on the BOM:

.Depending on a BOM to import its dependency constraints
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/constraintsFromBOM/groovy",files="build.gradle[tags=dependency-on-bom]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/constraintsFromBOM/kotlin",files="build.gradle.kts[tags=dependency-on-bom]"]
====

In the example, the versions of `gson` and `dom4j` are provided by the Spring Boot BOM.
This way, if you are developing for a platform like Spring Boot, you do not have to declare any versions yourself but can rely on the versions the platform provides.

Gradle treats all entries in the `<dependencyManagement>` block of a BOM similar to <<#sec:adding-constraints-transitive-deps,Gradle's dependency constraints>>.
This means that any version defined in the `<dependencyManagement>` block can impact the dependency resolution result.
In order to qualify as a BOM, a `.pom` file needs to have `<packaging>pom</packaging>` set.

However often BOMs are not only providing versions as recommendations, but also a way to override any other version found in the graph.
You can enable this behavior by using the `enforcedPlatform` keyword, instead of `platform`, when importing the BOM:

.Importing a BOM, making sure the versions it defines override any other version found
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/enforcedConstraintsFromBOM/groovy",files="build.gradle[tags=dependency-on-bom]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/enforcedConstraintsFromBOM/kotlin",files="build.gradle.kts[tags=dependency-on-bom]"]
====

[[sec:version_alignment]]
== Aligning dependency versions

Dependency version alignment allows different modules belonging to the same logical group (a _platform_) to have identical versions in a dependency graph.

=== Handling inconsistent module versions

Gradle supports aligning versions of modules which belong to the same "platform".
It is often preferable, for example, that the API and implementation modules of a component are using the same version.
However, because of the game of transitive dependency resolution, it is possible that different modules belonging to the same platform end up using different versions.
For example, your project may depend on the `jackson-databind` and `vert.x` libraries, as illustrated below:

.Declaring dependencies
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/dependencyAlignment/groovy",files="build.gradle[tags=dependencies]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/dependencyAlignment/kotlin",files="build.gradle.kts[tags=dependencies]"]
====

Because `vert.x` depends on `jackson-core`, we would actually resolve the following dependency versions:

- `jackson-core` version `2.9.5` (brought by `vertx-core`)
- `jackson-databind` version `2.9.5` (by conflict resolution)
- `jackson-annotation` version `2.9.0` (dependency of `jackson-databind:2.9.5`)

It's easy to end up with a set of versions which do not work well together.
To fix this, Gradle supports dependency version alignment, which is supported by the concept of platform.
A platform represents a set of modules which "work well together".
Either because they are actually published as a whole (when one of the members of the platform is published, all other modules are also published with the same version), or because someone tested modules and indicates that they work well together (typically, the Spring Platform).

=== Aligning versions natively with Gradle

Gradle natively supports alignment of modules produced by Gradle.
This is a direct consequence of the transitivity of <<sec:adding-constraints-transitive-deps, dependency constraints>>.
So if you have a multi-project build, and that you wish that consumers get the same version of all your modules, Gradle provides a simple way to do this using the <<java_platform_plugin.adoc#,Java Platform Plugin>>.

For example, if you have a project that consists of 3 modules:

- `lib`
- `utils`
- `core`, depending on `lib` and `utils`

And a consumer that declares the following dependencies:

- `core` version 1.0
- `lib` version 1.1

then by default resolution would select `core:1.0` and `lib:1.1`, because `lib` has no dependency on `core`.
We can fix this by adding a new module in our project, a _platform_, that will add constraints on all the modules of your project:

.The platform module
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/dependencyAlignmentWithPlatform/groovy/platform",files="build.gradle[tags=platform]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/dependencyAlignmentWithPlatform/kotlin/platform",files="build.gradle.kts[tags=platform]"]
====

Once this is done, we need to make sure that all modules now _depend on the platform_, like this:

.Declaring a dependency on the platform
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/dependencyAlignmentWithPlatform/groovy/core",files="build.gradle[tags=dependencies]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/dependencyAlignmentWithPlatform/kotlin/core",files="build.gradle.kts[tags=dependencies]"]
====

It is important that the platform contains a constraint on all the components, but also that each component has a dependency on the platform.
By doing this, whenever Gradle will add a dependency to a module of the platform on the graph, it will _also_ include constraints on the other modules of the platform.
This means that if we see another module belonging to the same platform, we will automatically upgrade to the same version.

In our example, it means that we first see `core:1.0`, which brings a platform `1.0` with constraints on `lib:1.0` and `lib:1.0`.
Then we add `lib:1.1` which has a dependency on `platform:1.1`.
By conflict resolution, we select the `1.1` platform, which has a constraint on `core:1.1`.
Then we conflict resolve between `core:1.0` and `core:1.1`, which means that `core` and `lib` are now aligned properly.

NOTE: This behavior is enforced for published components only if you use Gradle Module Metadata.

=== Aligning versions of modules not published with Gradle

Whenever the publisher doesn't use Gradle, like in our Jackson example, we can explain to Gradle that that all Jackson modules "belong to" the same platform and benefit from the same behavior as with native alignment:

.A dependency version alignment rule
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/dependencyAlignment/groovy",files="build.gradle[tags=alignment-rule]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/dependencyAlignment/kotlin",files="build.gradle.kts[tags=alignment-rule]"]
====

By using the `belongsTo` keyword, we declare that all modules belong to the same _virtual platform_, which is treated specially by the engine, in particular with regards to alignment. We can use the rule we just created by registering it:

.Making use of a dependency version alignment rule
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/dependencyAlignment/groovy",files="build.gradle[tags=use_rule]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/dependencyAlignment/kotlin",files="build.gradle.kts[tags=use_rule]"]
====

Then all versions in the example above would align to `2.9.5`. However, Gradle would let you override that choice by specifying a dependency on the Jackson platform:

.Forceful platform downgrade
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/dependencyAlignment/groovy",files="build.gradle[tags=enforced_platform]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/dependencyAlignment/kotlin",files="build.gradle.kts[tags=enforced_platform]"]
====

[[sec:virtual_platform]]
=== Virtual vs published platforms

A platform defined by a component metadata rule for which the `belongsTo` target module isn't published on a repository is called a virtual platform.
A virtual platform is considered specially by the engine and participates in dependency resolution like a published module, but triggers dependency version alignment.
On the other hand, we can find "real" platforms published on public repositories. Typical examples include BOMs, like the Spring BOM. They differ in the sense that a published platform may refer to modules which are effectively different things.
For example the Spring BOM declares dependencies on Spring as well as Apache Groovy. Obviously those things are versioned differently, so it doesn't make sense to align in this case. In other words, if a platform is _published_, Gradle trusts its metadata, and will not try to align dependency versions of this platform.

[[aligning-for-consumers]]
=== For your consumers

[[aligning-for-your-deps]]
=== For dependencies you consume

[[sec:matching-dependencies-to-repos]]
== Matching dependencies to repositories

Gradle exposes an API to declare what a repository may or may not contain.
This feature offers a fine grained control on which repository serve which artifacts, which can be one way of controlling the source of dependencies.

Head over to <<declaring_repositories.adoc#sec:repository-content-filtering,the section on repository content filtering>> to know more about this feature.

[[sec:enforcing_dependency_version]]
== Forcing dependency versions

Gradle resolves any dependency version conflicts by selecting the latest version found in the dependency graph.
Some projects might need to divert from the default behavior and enforce an earlier version of a dependency e.g. if the source code of the project depends on an older API of a dependency than some of the external libraries.

[NOTE]
====
Enforcing a version of a dependency requires a conscious decision.
Changing the version of a transitive dependency might lead to runtime errors if external libraries do not properly function without them.
Consider upgrading your source code to use a newer version of the library as an alternative approach.
====

Let's say a project uses the link:https://hc.apache.org/httpcomponents-client-ga/[HttpClient library] for performing HTTP calls. HttpClient pulls in link:https://commons.apache.org/proper/commons-codec/[Commons Codec] as transitive dependency with version 1.10. However, the production source code of the project requires an API from Commons Codec 1.9 which is not available in 1.10 anymore. A dependency version can be enforced by declaring it in the build script and setting link:{javadocPath}/org/gradle/api/artifacts/ExternalDependency.html#setForce-boolean-[ExternalDependency.setForce(boolean)] to `true`.

.Enforcing a dependency version
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/forceForDependency/groovy",files="build.gradle[tags=force-per-dependency]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/forceForDependency/kotlin",files="build.gradle.kts[tags=force-per-dependency]"]
====

If the project requires a specific version of a dependency on a configuration-level then it can be achieved by calling the method link:{groovyDslPath}/org.gradle.api.artifacts.ResolutionStrategy.html#org.gradle.api.artifacts.ResolutionStrategy:force(java.lang.Object++[]++)[ResolutionStrategy.force(java.lang.Object++[]++)].

.Enforcing a dependency version on the configuration-level
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/forceForConfiguration/groovy",files="build.gradle[tags=force-per-configuration]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/forceForConfiguration/kotlin",files="build.gradle.kts[tags=force-per-configuration]"]
====

[[sec:dependency_resolve_rules]]
== Dependency resolve rules

A dependency resolve rule is executed for each resolved dependency, and offers a powerful api for manipulating a requested dependency prior to that dependency being resolved.
The feature currently offers the ability to change the group, name and/or version of a requested dependency, allowing a dependency to be substituted with a completely different module during resolution.

Dependency resolve rules provide a very powerful way to control the dependency resolution process, and can be used to implement all sorts of advanced patterns in dependency management.
Some of these patterns are outlined below.
or more information and code samples see the link:{groovyDslPath}/org.gradle.api.artifacts.ResolutionStrategy.html[ResolutionStrategy] class in the API documentation.

[[sec:custom_versioning_scheme]]
=== Implementing a custom versioning scheme

In some corporate environments, the list of module versions that can be declared in Gradle builds is maintained and audited externally.
Dependency resolve rules provide a neat implementation of this pattern:

* In the build script, the developer declares dependencies with the module group and name, but uses a placeholder version, for example: `default`.
* The `default` version is resolved to a specific version via a dependency resolve rule, which looks up the version in a corporate catalog of approved modules.

This rule implementation can be neatly encapsulated in a corporate plugin, and shared across all builds within the organisation.

.Using a custom versioning scheme
====
include::sample[dir="userguide/dependencyManagement/customizingResolution/resolutionStrategy/groovy",files="build.gradle[tags=custom-versioning-scheme]"]
include::sample[dir="userguide/dependencyManagement/customizingResolution/resolutionStrategy/kotlin",files="build.gradle.kts[tags=custom-versioning-scheme]"]
====

[[sec:blacklisting_version]]
=== Blacklisting a particular version with a replacement

Dependency resolve rules provide a mechanism for blacklisting a particular version of a dependency and providing a replacement version.
This can be useful if a certain dependency version is broken and should not be used, where a dependency resolve rule causes this version to be replaced with a known good version.
One example of a broken module is one that declares a dependency on a library that cannot be found in any of the public repositories, but there are many other reasons why a particular module version is unwanted and a different version is preferred.

In example below, imagine that version `1.2.1` contains important fixes and should always be used in preference to `1.2`.
The rule provided will enforce just this: any time version `1.2` is encountered it will be replaced with `1.2.1`.
Note that this is different from a forced version as described above, in that any other versions of this module would not be affected.
This means that the 'newest' conflict resolution strategy would still select version `1.3` if this version was also pulled transitively.

.Example: Blacklisting a version with a replacement
====
include::sample[dir="userguide/dependencyManagement/customizingResolution/resolutionStrategy/groovy",files="build.gradle[tags=blacklisting_version]"]
include::sample[dir="userguide/dependencyManagement/customizingResolution/resolutionStrategy/kotlin",files="build.gradle.kts[tags=blacklisting_version]"]
====

[NOTE]
====
There's a difference with using the _reject_ directive of <<rich_versions.adoc#rich-version-constraints,rich version constraints>>: rich versions will cause the build to fail if a rejected version is found in the graph, or select a non rejected version when using dynamic dependencies.
Here, we _manipulate the requested versions_ in order to select a different version when we find a rejected one.
In other words, this is a _solution_ to rejected versions, while rich version constraints allow declaring the _intent_ (you should not use this version).
====

[[excluding-transitive-deps]]
== Excluding transitive dependencies

Declared dependencies in a build script can pull in a lot of transitive dependencies. You might decide that you do not want a particular transitive dependency as part of the dependency graph for a good reason.

- The dependency is undesired due to licensing constraints.
- The dependency is not available in any of the declared repositories.
- The metadata for the dependency exists but the artifact does not.
- The metadata provides incorrect coordinates for a transitive dependency.

Transitive dependencies can be excluded on the level of a declared dependency or a configuration. Let's demonstrate both use cases. In the following two examples the build script declares a dependency on Log4J, a popular logging framework in the Java world. The metadata of the particular version of Log4J also defines transitive dependencies.

.Unresolved artifacts for transitive dependencies
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/unresolved/groovy",files="build.gradle[tags=unresolved-transitive-dependencies]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/unresolved/kotlin",files="build.gradle.kts[tags=unresolved-transitive-dependencies]"]
====

If resolved from Maven Central some of the transitive dependencies provide metadata but not the corresponding binary artifact. As a result any task requiring the binary files will fail e.g. a compilation task.

[listing]
----
> gradle -q compileJava

* What went wrong:
Could not resolve all files for configuration ':compileClasspath'.
> Could not find jms.jar (javax.jms:jms:1.1).
  Searched in the following locations:
      https://repo.maven.apache.org/maven2/javax/jms/jms/1.1/jms-1.1.jar
> Could not find jmxtools.jar (com.sun.jdmk:jmxtools:1.2.1).
  Searched in the following locations:
      https://repo.maven.apache.org/maven2/com/sun/jdmk/jmxtools/1.2.1/jmxtools-1.2.1.jar
> Could not find jmxri.jar (com.sun.jmx:jmxri:1.2.1).
  Searched in the following locations:
      https://repo.maven.apache.org/maven2/com/sun/jmx/jmxri/1.2.1/jmxri-1.2.1.jar
----

The situation can be fixed by adding a repository containing those dependencies. In the given example project, the source code does not actually use any of Log4J's functionality that require the JMS (e.g. `link:https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/net/JMSAppender.html[JMSAppender]`) or JMX libraries. It's safe to exclude them from the dependency declaration.

Exclusions need to spelled out as a key/value pair via the attributes `group` and/or `module`. For more information, refer to link:{javadocPath}/org/gradle/api/artifacts/ModuleDependency.html#exclude-java.util.Map-[ModuleDependency.exclude(java.util.Map)].

.Excluding transitive dependency for a particular dependency declaration
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/excludeForDependency/groovy",files="build.gradle[tags=exclude-transitive-dependencies]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/excludeForDependency/kotlin",files="build.gradle.kts[tags=exclude-transitive-dependencies]"]
====

You may find that other dependencies will want to pull in the same transitive dependency that misses the artifacts. Alternatively, you can exclude the transitive dependencies for a particular configuration by calling the method link:{groovyDslPath}/org.gradle.api.artifacts.Configuration.html#org.gradle.api.artifacts.Configuration:exclude(java.util.Map)[Configuration.exclude(java.util.Map)].

.Excluding transitive dependency for a particular configuration
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/excludeForConfiguration/groovy",files="build.gradle[tags=exclude-transitive-dependencies]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/excludeForConfiguration/kotlin",files="build.gradle.kts[tags=exclude-transitive-dependencies]"]
====

[NOTE]
====
As a build script author you often times know that you want to exclude a dependency for all configurations available in the project. You can use the method link:{javadocPath}/org/gradle/api/DomainObjectCollection.html#all-org.gradle.api.Action-[DomainObjectCollection.all(org.gradle.api.Action)] to define a global rule.
====

You might encounter other use cases that don't quite fit the bill of an exclude rule. For example you want to automatically select a version for a dependency with a specific requested version or you want to select a different group for a requested dependency to react to a relocation. Those use cases are better solved by the link:{groovyDslPath}/org.gradle.api.artifacts.ResolutionStrategy.html[ResolutionStrategy] API. Some of these use cases are covered in <<customizing_dependency_resolution_behavior.adoc#customizing_dependency_resolution_behavior,Customizing Dependency Resolution Behavior>>.

[[sec:disabling_resolution_transitive_dependencies]]
== Disabling transitive resolution

By default Gradle resolves all transitive dependencies specified by the dependency metadata.
Sometimes this behavior may not be desirable e.g. if the metadata is incorrect or defines a large graph of transitive dependencies.
You can tell Gradle to disable transitive dependency management for a dependency by setting link:{javadocPath}/org/gradle/api/artifacts/ModuleDependency.html#setTransitive-boolean-[ModuleDependency.setTransitive(boolean)] to `false`.
As a result only the main artifact will be resolved for the declared dependency.

.Disabling transitive dependency resolution for a declared dependency
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/disableForDependency/groovy",files="build.gradle[tags=transitive-per-dependency]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/disableForDependency/kotlin",files="build.gradle.kts[tags=transitive-per-dependency]"]
====

[NOTE]
====
Disabling transitive dependency resolution will likely require you to declare the necessary runtime dependencies in your build script which otherwise would have been resolved automatically. Not doing so might lead to runtime classpath issues.
====

A project can decide to disable transitive dependency resolution completely.
You either don't want to rely on the metadata published to the consumed repositories or you want to gain full control over the dependencies in your graph.
For more information, see link:{javadocPath}/org/gradle/api/artifacts/Configuration.html#setTransitive-boolean-[Configuration.setTransitive(boolean)].

.Disabling transitive dependency resolution on the configuration-level
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/disableForConfiguration/groovy",files="build.gradle[tags=transitive-per-configuration]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/disableForConfiguration/kotlin",files="build.gradle.kts[tags=transitive-per-configuration]"]
====

[[sec:handling-mutually-exclusive-deps]]
== Handling mutually exclusive dependencies

[[sub:capabilities]]
=== Introduction to component capabilities

Often a dependency graph would accidentally contain multiple implementations of the same API.
This is particularly common with logging frameworks, where multiple bindings are available, and that one library chooses a binding when another transitive dependency chooses another.
Because those implementations live at different GAV coordinates, the build tool has usually no way to find out that there's a conflict between those libraries.
To solve this, Gradle provides the concept of _capability_.

It's illegal to find two components providing the same _capability_ in a single dependency graph.
Intuitively, it means that if Gradle finds two components that provide the same thing on classpath, it's going to fail with an error indicating what modules are in conflict.
In our example, it means that different bindings of a logging framework provide the same capability.

=== Capability coordinates

A _capability_ is defined by a `(group, module, version)` triplet.
Each component defines an implicit capability corresponding to its GAV coordinates (group, artifact, version).
For example, the `org.apache.commons:commons-lang3:3.8` module has an implicit capability with group `org.apache.commons`, name `commons-lang3` and version `3.8`.
It is important to realize that capabilities are _versioned_.

=== Declaring component capabilities

By default, Gradle will fail if two components in the dependency graph provide the same capability.
Because most modules are currently published without Gradle Module Metadata, capabilities are not always automatically discovered by Gradle.
It is however interesting to use _rules_ to declare component capabilities in order to discover conflicts as soon as possible, during the build instead of runtime.

A typical example is whenever a component is relocated at different coordinates in a new release.
For example, the ASM library lived at `asm:asm` coordinates until version `3.3.1`, then changed to `org.ow2.asm:asm` since `4.0`.
It is illegal to have both ASM <=3.3.1 and 4.0+ on the classpath, because they provide the same feature, it's just that the component has been relocated.
Because each component has an implicit capability corresponding to its GAV coordinates, we can "fix" this by having a rule that will declare that the `asm:asm` module provides the `org.ow2.asm:asm` capability:

.Conflict resolution by capability
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/declaringCapabilities/groovy",files="build.gradle[tags=fix_asm]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/declaringCapabilities/kotlin",files="build.gradle.kts[tags=fix_asm]"]
====

Now the build is going to _fail_ whenever the two components are found in the same dependency graph.

[NOTE]
====
At this stage, Gradle will _only_ make more builds fail.
It will **not** automatically fix the problem for you, but it helps you realize that you have a problem.
It is recommended to write such rules in _plugins_ which are then applied to your builds.
Then, users _have to_ express their preferences, if possible, or fix the problem of having incompatible things on the classpath, as explained in the following section.
====

[[sub:selecting-between-candidates]]
=== Selecting between candidates

At some point, a dependency graph is going to include either _incompatible modules_, or modules which are _mutually exclusive_.
For example, you may have different logger implementations and you need to choose one binding.
<<#sub:capabilities,Capabilities>> help _realizing_ that you have a conflict, but Gradle also provides tools to express how to solve the conflicts.

[[sub:selecting-preferred-capability-provider]]
==== Selecting between different capability candidates

In the relocation example above, Gradle was able to tell you that you have two versions of the same API on classpath: an "old" module and a "relocated" one.
Now we can solve the conflict by automatically choosing the component which has the highest capability version:

.Conflict resolution by capability versioning
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/declaringCapabilities/groovy",files="build.gradle[tags=use_highest_asm]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/declaringCapabilities/kotlin",files="build.gradle.kts[tags=use_highest_asm]"]
====

However, fixing by choosing the highest capability version conflict resolution is not always suitable.
For a logging framework, for example, it doesn't matter what version of the logging frameworks we use, we should always select Slf4j.

In this case, we can fix it by explicitly selecting slf4j as the winner:

.Substitute log4j with slf4j
====
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/declaringCapabilities/groovy",files="build.gradle[tags=use_slf4j]"]
include::sample[dir="userguide/dependencyManagement/managingTransitiveDependencies/declaringCapabilities/kotlin",files="build.gradle.kts[tags=use_slf4j]"]
====

Note that this approach works also well if you have multiple _Slf4j bindings_ on the classpath:
bindings are basically different logger implementations and you need only one.
However, the selected implementation may depend on the configuration being resolved.
For example, for tests, `slf4j-simple` may be enough but for production, `slf4-over-log4j` may be better.

For more information, check out the link:{javadocPath}/org/gradle/api/artifacts/ResolutionStrategy.html#capabilitiesResolution[the capabilities resolution API].

[[sec:module_replacement]]
== Module replacement rules

It is preferable to express module conflicts in terms of <<sub:capabilities, capabilities conflicts>>.
However, if there's no such rule declared or that you are working on versions of Gradle which do not support capabilities, Gradle provides tooling to work around those issues.

Module replacement rules allow a build to declare that a legacy library has been replaced by a new one.
A good example when a new library replaced a legacy one is the `google-collections` -&gt; `guava` migration.
The team that created google-collections decided to change the module name from `com.google.collections:google-collections` into `com.google.guava:guava`.
This is a legal scenario in the industry: teams need to be able to change the names of products they maintain, including the module coordinates. Renaming of the module coordinates has impact on conflict resolution.

To explain the impact on conflict resolution, let's consider the `google-collections` -&gt; `guava` scenario.
It may happen that both libraries are pulled into the same dependency graph.
For example, _our project_ depends on `guava` but some of _our dependencies_ pull in a legacy version of `google-collections`.
This can cause runtime errors, for example during test or application execution.
Gradle does not automatically resolve the `google-collections` -&gt; `guava` conflict because it is not considered as a _version conflict_.
It's because the module coordinates for both libraries are completely different and conflict resolution is activated when `group` and `module` coordinates are the same but there are different versions available in the dependency graph (for more info, refer to the section on conflict resolution).
Traditional remedies to this problem are:

* Declare exclusion rule to avoid pulling in `google-collections` to graph. It is probably the most popular approach.
* Avoid dependencies that pull in legacy libraries.
* Upgrade the dependency version if the new version no longer pulls in a legacy library.
* Downgrade to `google-collections`. It's not recommended, just mentioned for completeness.

Traditional approaches work but they are not general enough.
For example, an organisation wants to resolve the `google-collections` -&gt; `guava` conflict resolution problem in all projects.
It is possible to declare that certain module was replaced by other.
This enables organisations to include the information about module replacement in the corporate plugin suite and resolve the problem holistically for all Gradle-powered projects in the enterprise.

.Declaring a module replacement
====
include::sample[dir="userguide/dependencyManagement/customizingResolution/replacementRule/groovy",files="build.gradle[tags=module_replacement_declaration]"]
include::sample[dir="userguide/dependencyManagement/customizingResolution/replacementRule/kotlin",files="build.gradle.kts[tags=module_replacement_declaration]"]
====

For more examples and detailed API, refer to the DSL reference for link:{javadocPath}/org/gradle/api/artifacts/dsl/ComponentMetadataHandler.html[ComponentMetadataHandler].

What happens when we declare that `google-collections` is replaced by `guava`?
Gradle can use this information for conflict resolution. Gradle will consider every version of `guava` newer/better than any version of `google-collections`.
Also, Gradle will ensure that only guava jar is present in the classpath / resolved file list.
Note that if only `google-collections` appears in the dependency graph (e.g. no `guava`) Gradle will not eagerly replace it with `guava`.
Module replacement is an information that Gradle uses for resolving conflicts.
If there is no conflict (e.g. only `google-collections` or only `guava` in the graph) the replacement information is not used.

Currently it is not possible to declare that a given module is replaced by a set of modules.
However, it is possible to declare that multiple modules are replaced by a single module.

[[sec:dependency_substitution_rules]]
== Using dependency substitution rules

Dependency substitution rules work similarly to dependency resolve rules.
In fact, many capabilities of dependency resolve rules can be implemented with dependency substitution rules.
 They allow project and module dependencies to be transparently substituted with specified replacements.
 Unlike dependency resolve rules, dependency substitution rules allow project and module dependencies to be substituted interchangeably.

_Adding a dependency substitution rule to a configuration changes the timing of when that configuration is resolved._
Instead of being resolved on first use, the configuration is instead resolved when the task graph is being constructed.
This can have unexpected consequences if the configuration is being further modified during task execution, or if the configuration relies on modules that are published during execution of another task.

To explain:

* A `Configuration` can be declared as an input to any Task, and that configuration can include project dependencies when it is resolved.
* If a project dependency is an input to a Task (via a configuration), then tasks to build the project artifacts must be added to the task dependencies.
* In order to determine the project dependencies that are inputs to a task, Gradle needs to resolve the `Configuration` inputs.
* Because the Gradle task graph is fixed once task execution has commenced, Gradle needs to perform this resolution prior to executing any tasks.

In the absence of dependency substitution rules, Gradle knows that an external module dependency will never transitively reference a project dependency.
This makes it easy to determine the full set of project dependencies for a configuration through simple graph traversal.
With this functionality, Gradle can no longer make this assumption, and must perform a full resolve in order to determine the project dependencies.

[[sub:module_to_project_substitution]]
=== Substituting an external module dependency with a project dependency

One use case for dependency substitution is to use a locally developed version of a module in place of one that is downloaded from an external repository.
This could be useful for testing a local, patched version of a dependency.

The module to be replaced can be declared with or without a version specified.

.Substituting a module with a project
====
include::sample[dir="userguide/dependencyManagement/customizingResolution/substitutionRule/groovy",files="build.gradle[tags=module_to_project_substitution]"]
include::sample[dir="userguide/dependencyManagement/customizingResolution/substitutionRule/kotlin",files="build.gradle.kts[tags=module_to_project_substitution]"]
====

Note that a project that is substituted must be included in the multi-project build (via `settings.gradle`).
Dependency substitution rules take care of replacing the module dependency with the project dependency and wiring up any task dependencies, but do not implicitly include the project in the build.

[[sub:project_to_module_substitution]]
=== Substituting a project dependency with a module replacement

Another way to use substitution rules is to replace a project dependency with a module in a multi-project build.
This can be useful to speed up development with a large multi-project build, by allowing a subset of the project dependencies to be downloaded from a repository rather than being built.

The module to be used as a replacement must be declared with a version specified.

.Substituting a project with a module
====
include::sample[dir="userguide/dependencyManagement/customizingResolution/substitutionRule/groovy",files="build.gradle[tags=project_to_module_substitution]"]
include::sample[dir="userguide/dependencyManagement/customizingResolution/substitutionRule/kotlin",files="build.gradle.kts[tags=project_to_module_substitution]"]
====

When a project dependency has been replaced with a module dependency, that project is still included in the overall multi-project build.
However, tasks to build the replaced dependency will not be executed in order to resolve the depending `Configuration`.

[[sub:conditional_dependency_substitution]]
=== Conditionally substituting a dependency

A common use case for dependency substitution is to allow more flexible assembly of sub-projects within a multi-project build.
This can be useful for developing a local, patched version of an external dependency or for building a subset of the modules within a large multi-project build.

The following example uses a dependency substitution rule to replace any module dependency with the group `org.example`, but only if a local project matching the dependency name can be located.

.Conditionally substituting a dependency
====
include::sample[dir="userguide/dependencyManagement/customizingResolution/conditionalSubstitutionRule/groovy",files="build.gradle[tags=project_substitution]"]
include::sample[dir="userguide/dependencyManagement/customizingResolution/conditionalSubstitutionRule/kotlin",files="build.gradle.kts[tags=project_substitution]"]
====

Note that a project that is substituted must be included in the multi-project build (via `settings.gradle`).
Dependency substitution rules take care of replacing the module dependency with the project dependency, but do not implicitly include the project in the build.

[[sec:fixing-bad-metadata]]
== Fixing bad metadata

include::component_metadata_rules.adoc[leveloffset=+2]

[[sec:ivy_dynamic_resolve_mode]]
== Enabling Ivy dynamic resolve mode

Gradle's Ivy repository implementations support the equivalent to Ivy's dynamic resolve mode. Normally, Gradle will use the `rev` attribute for each dependency definition included in an `ivy.xml` file. In dynamic resolve mode, Gradle will instead prefer the `revConstraint` attribute over the `rev` attribute for a given dependency definition. If the `revConstraint` attribute is not present, the `rev` attribute is used instead.

To enable dynamic resolve mode, you need to set the appropriate option on the repository definition. A couple of examples are shown below. Note that dynamic resolve mode is only available for Gradle's Ivy repositories. It is not available for Maven repositories, or custom Ivy `DependencyResolver` implementations.

.Enabling dynamic resolve mode
====
include::sample[dir="userguide/dependencyManagement/customizingResolution/ivyDynamicMode/groovy",files="build.gradle[tags=ivy-repo-dynamic-mode]"]
include::sample[dir="userguide/dependencyManagement/customizingResolution/ivyDynamicMode/kotlin",files="build.gradle.kts[tags=ivy-repo-dynamic-mode]"]
====
